I attempted to make clear in the abstract that the aim of the paper is to present an overview of the architecture of Whirlwind. This should have been made explicit in the title of the paper. I would now like to change the title to "Architecture of Whirlwind: an Internet services platform with overload protection, fault–tolerance and self–tuning". 

It is practically impossible to cover everything in a paper within the page limit. I did not feel I could provide a reasonably complete performance analysis while still presenting the architecture and the motivation for the architectural decisions.

Part of the reason is that the architecture allows the developer to specify arbitrary scheduling algorithms, self tuning algorithms and admission control algorithms for different groups (a.k.a. layers) of the application and the interaction between these resource control policies within a layer and across layers can be complex. 

Application design involves selecting the number of layers and resource control policies for each layer. Depending on the performance goals, Whirlwind applications can be optimized for throughput, or attempt to maintain soft response time bounds or optimize for some other metric (such as revenue generation). It is also possible to create applications where the performance goals can be adjusted at deploy time by reconfiguring the set of resource control policies. Trade-offs made during application design and configuration phases will have a significant impact on the performance of the application. 

If the referees insist, I could include some graphs to illustrate the performance of a particular Whirlwind application, subjected to specific workload (s), configured to use specific scheduling algorithm (s), specific admission control algorithm (s) and specific self-tuning algorithm (s). It would need to be presented with the caveat that it is only one approach and is not necessarily representative of Whirlwind used in another context.

It should be noted that several of the techniques used within Whirlwind have been previously published but they have never been combined in one comprehensive framework.  Combining these techniques in one framework made it possible to compare the techniques on equal ground. It also made it easy to investigate the interaction between scheduling and admission control policies and the implications for application design and performance.